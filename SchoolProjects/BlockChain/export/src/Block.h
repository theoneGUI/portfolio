#pragma once
#include <string>
#include <unordered_map>
#include "picosha2.h"
#include <cmath>
#include "rapidjson/document.h"
#include "rapidjson/stringbuffer.h"
#include "rapidjson/writer.h"

using namespace std;
using namespace rapidjson;
using std::string;

// forward declarations for friend class directives
class BlockMesserUpper;
class BlockChain;

class Block {
public:
	friend class BlockMesserUpper;
	friend class BlockChain;
	// There is a certain degree to which you have control over what information you want to provide to instantiate a Block, some is automatically generated by the BlockChain when a new block is added
	Block(const string& sender, const string& receiver, size_t nonce, const string& previousHash, int difficulty, const string& data);
	Block(const string& sender, const string& receiver, const string& previousHash, int difficulty, const string& data);
	string getSender();
	string getReceiver();
	string getPreviousHash();
	string getData();
	size_t getNonce();
	int getDifficulty();
	string figureOutNonce();
	// This function will decide whether to re-figure out its nonce or not based on the boolean flags below. If required, it will do it automatically; if not, it won't
	string getBlockHash();

private:
	string hashBlock(int difficulty);
	bool starts_with_n_zeros(string s, int n);
	string getHashable(size_t nonce);
	string getHashable();

	// boolean flags to determine whether or not the Block needs to figure out its nonce
	bool nonceProvided = true;
	bool nonceFigured = false;
	string sender;
	string receiver;
	string previousHash;
	int difficulty;
	size_t nonce;
	string data;
};

class BlockMesserUpper {
public:
	static void messUpData(Block& x, const string& newData);
};